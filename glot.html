<!DOCTYPE html>
<html>
<head>
	<!--
		This is a very early version of what will become WebGLot - a WebGL-
		based plotting library for mathematical primitives.
	-->
	<title>WebGLot Alpha</title>
	
	<!--
		This is a matrix library I have been using for the time being, though
		I may move to something more standard.  I originally got this code from
		http://webkit.org/blog/603/webgl-now-available-in-webkit-nightlies/
	-->
	<script src="CanvasMatrix.js"> </script>
	
	<!--
		These are the class files used in WebGLot. I'm not really an expert
		in JavaScript, and would prefer an analog to the #include macro in
		C++ for this task so that only one script must be included.  For the
		time being, just copy-and-paste this.
	-->
	<script src="emptytexture.js"> </script>
	<script src="texture.js">   </script>
	<script src="ray.js">       </script>
	<script src="primitive.js"> </script>
	<script src="pde.js">       </script>
	<script src="sphere.js">    </script>
	<script src="stopwatch.js"> </script>
	<script src="screen.js">    </script>
	<script src="surface.js">   </script>
	<script src="p_surface.js"> </script>
	<script src="grapher.js">   </script>

	<script>
	function start() {
		/* Instantiate a grapher
		 *
		 * In the C++ version, it's a singleton, and so it's possible that
		 * this interface will change, so use with caution.
		 */
		var glot = new grapher();
		
		glot.add(new sphere(0, 0, 0));
		
		// You can add new primitives to the display with the add function.
		//glot.add(new surface(glot.getContext(), "sin(sqrt(x * x + y * y) + t)"));
		//glot.add(new surface("sin(3.0 * sqrt(x * x + y * y) - 2.0 * t) * exp(-sqrt(x * x + y * y)/5.0) * cos(5.0 * sqrt((x - 1.5) * (x - 1.5) + (y - 0.75) * (y - 0.75)) - t) / 3.0"));
		
		//glot.add(new pde());
		
		/*
		// Another of Alyn's surfaces
		glot.setDomain(0, 2, 0, 2);
		glot.add(new surface("(pow(10.0, -9.0) * x * y * pow(10.0, 15.0) * (-4.2805 * x + 4.5067 * y - 8.2939 * x * x - 7.630209 * x * y - 16.6313 * y * y + 1.7667 * x * x * y + 1.916284 * x * y * y - 1.13259 * pow(x, 3.0) * y + 0.33383 * pow(x, 4.0) * y - 1.88588 * pow(x, 3.0) * pow(y, 2.0) + 2.847 * pow(x, 2.0) * pow(y, 2.0) + 1.4387 * pow(x, 2.0) * pow(y, 3.0) - 18.69 * x * pow(y, 3.0) + 5.01255 * x * pow(y, 4.0) + 12.598 * pow(x, 3.0) + 12.8728 * pow(y, 3.0) - 6.05277 * pow(x, 4.0) + 1.0313 * pow(x, 5.0) - 4.4697 * pow(y, 4.0) + 1.42018 * pow(y, 5.0) + 6.17273)) / (pow(10.0, 6.0) * (6.718464 * x + 6.718 * y - 15.3867 * pow(x, 2.0) - 12.1991 * x * y - 13.06368 * pow(y, 2.0) + 18.392 * pow(x, 2.0) * y + 21.8256 * x * pow(y, 2.0) - 13.2552 * pow(x, 3.0) * y + 1.489 * pow(x, 4.0) * y + 35.65 * pow(x, 3.0) * pow(y, 2.0) - 39.832880 * pow(x, 2.0) * pow(y, 2.0) + 3.4069 * pow(x, 2.0) * pow(y, 3.0) + 16.438 * x * pow(y, 3.0) - 42.25 * x * pow(y, 4.0) - 1.2281750 * pow(x, 4.0) * pow(y, 2.0) - 9.3458 * pow(x, 3.0) * pow(y, 3.0) + 17.5555 * pow(x, 2.0) * pow(y, 4.0) + 1.440250 * pow(x, 5.0) * y + 14.9125 * x * pow(y, 5.0) + 2.755625 * pow(x, 4.0) * pow(y, 3.0) - 2.16 * pow(x, 3.0) * pow(y, 4.0) - 4.715 * pow(x, 2.0) * pow(y, 5.0) + 1.094375 * pow(x, 5.0) * pow(y, 2.0) + 1.05 * x * pow(y, 6.0) - 0.290625 * y * pow(x, 6.0) + 12.224016 * pow(x, 3.0) - 4.536 * pow(y, 3.0) - 2.87386 * pow(x, 4.0) - 0.42260 * pow(x, 5.0) + 18.36 * pow(y, 4.0) - 3.15 * pow(y, 5.0) + 0.145 * pow(x, 6.0) - 6.3 * pow(y, 6.0) + 2.25 * pow(y, 7.0) + 0.015625 * pow(x, 7.0)))"));
		//*/
		//glot.add(new surface(glot.getContext(), "max(sin(3.0 * sqrt(x * x + y * y) - 2.0 * t) * exp(-sqrt(x * x + y * y)/5.0) * cos(5.0 * sqrt((x - 1.5) * (x - 1.5) + (y - 0.75) * (y - 0.75)) - t) / 3.0, sin(sqrt(x * x + y * y) + t))"));
		//glot.add(new surface("sin(sqrt(x * x + y * y))"));
		//glot.add(new p_surface("2.0 * 6.3 * v, 3.0 + sin(6.3 * v) + cos(6.3 * u), sin(6.3 * u) + 2.0 * cos(6.3 * v)"));
		
		/* If you've got a function that's time-dependent and thus you'd like
		 * for it to animate, then call glot.run.  It makes sure it constantly
		 * refreshes, otherwise the plot will be interactive, but static.  Well,
		 * that is to say, it will only refresh when the perpective changes,
		 * like with zooming in and out, or rotating it.
		 */
		glot.run();
	}
	</script>
	
	<style type="text/css">
	canvas {
		border: 1px solid black;
		width:100%;
		height:94%;
	}
	</style>
</head>
<body onload="start()">
	<!--
		WebGLot currently requires there to be a canvas with id="glot" to work.
		This will likely remain the default behavior, but there may be a new 
		interface added so that drawing on multiple canvases can take place.
		Though, it's a long way down on the roadmap.
	-->
	<canvas id="glot">It seems you do not have support for WebGL.</canvas>
	<div id="framerate">Framerate: </div>
</body>
</html>
